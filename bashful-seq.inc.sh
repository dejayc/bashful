#!/bin/bash

# Bashful is copyright 2009-2015 Dejay Clayton, all rights reserved:
#     https://github.com/dejayc/bashful
# Bashful is licensed under the 2-Clause BSD License:
#     http://opensource.org/licenses/BSD-2-Clause

# Initialize the namespace presence indicator, and verify dependencies.
{
    declare BASHFUL_MODULE_SEQ='bashful-seq.inc.sh'

    [[ -n "${BASHFUL_MODULE_LIST}" ]] || {

        echo "Aborting loading of '${BASHFUL_MODULE_SEQ}':"
        echo "Dependency 'bashful-list.inc.sh' is not loaded"
        exit 2
    } >&2
}

# function intSeq:
#
# Returns a separated list of non-negative integers, based on one or more
# input sequences of integers or integer ranges passed in as arguments.
#
# -n optionally preserves null items.
#
# -s optionally specifies an output separator.  Defaults to ' '.
#
# -u optionally generates only unique numbers, discarding duplicate numbers
#    from the output.
#
# Each number generated by an integer range will be padded with zeroes, if
# the number has less characters than any zero-padded numbers used to specify
# the integer range.  For example, integer range 10-08 will generate 10 09 08,
# while integer range 10-8 will generate 10 9 8.
#
# Examples:
#
# $ intSeq 2 4 6 10-08
# 2 4 6 10 09 08
#
# $ intSeq -u 5-8 10-6
# 5 6 7 8 10 9
#
# $ intSeq -s ':' 1-5
# 1:2:3:4:5
#
# $ intSeq -s ',' '1' '2' '' '4' '5' '' '6'
# 1,2,4,5,6
#
# $ intSeq -s ',' -n '1' '2' '' '4' '5' '' '6'
# 1,2,,4,5,,6
#
# $ intSeq -s ',' -n -u '1' '2' '' '4' '5' '' '6'
# 1,2,,4,5,6
function intSeq()
{
    local SEP=' '
    declare -i PRESERVE_NULL_ITEMS=0
    local FLAG_PRESERVE_NULL_ITEMS=''
    local FLAG_UNIQUE=''

    # Parse function options.
    declare -i OPTIND
    local OPT=''

    while getopts ':ns:u' OPT
    do
        case "${OPT}" in
        n)
            let PRESERVE_NULL_ITEMS=1
            FLAG_PRESERVE_NULL_ITEMS="-${OPT}"
            ;;
        s)
            SEP="${OPTARG}"
            ;;
        u)
            FLAG_UNIQUE="-${OPT}"
            ;;
        *)
            return 2
        esac
    done
    shift $(( OPTIND - 1 ))
    # Done parsing function options.

    declare -a RESULTS=()

    while [ $# -gt 0 ]
    do
        local ARG="${1}"
        shift

        # Handle empty sequences appropriately.
        [[ -n "${ARG}" ]] || {

            [[ ${PRESERVE_NULL_ITEMS} -ne 0 ]] && {

                RESULTS[${#RESULTS[@]}]=''
            }

            continue
        }

        [[ "${ARG}" =~ ^[[:space:]]*([0-9]+)[[:space:]]*$ ]] || \
        [[ "${ARG}" =~ \
^[[:space:]]*([0-9]+)[[:space:]]*-[[:space:]]*([0-9]+)[[:space:]]*$ ]] || \
            return 1

        local FROM_STR="${BASH_REMATCH[1]}"
        local TO_STR="${BASH_REMATCH[2]}"
        [[ -n "${TO_STR}" ]] || TO_STR="${FROM_STR}"

        # Record the length of the existing numbers, to later
        # determine if they are padded with zeroes.
        declare -i FROML=${#FROM_STR}
        declare -i TOL=${#TO_STR}

        # Convert numbers to proper decimal integers to remove leading
        # zeroes.
        declare -i FROM=10#"${FROM_STR}"
        declare -i TO=10#"${TO_STR}"

        # Determine if either of the numbers are padded with zeroes,
        # and if so, figure out how many digits of padding should be
        # used for each number in the sequence.
        declare -i L=0
        [[ ${FROML} -eq ${#FROM} ]] || let L=${FROML}
        [[ ${TOL} -eq ${#TO} ]] || { [[ ${TOL} -gt ${L} ]] && \
            let L=${TOL}; }

        # Generate the sequence.
        declare -i INC=1
        [[ ${FROM} -le ${TO} ]] || let INC=-1
        let TO+=INC

        while [ ${FROM} -ne ${TO} ]
        do
            local RESULT
            printf -v RESULT "%0${L}d" "${FROM}"
            RESULTS[${#RESULTS[@]}]="${RESULT}"
            let FROM+=INC
        done
    done

    # Generate the final output.
    translatedList \
        ${FLAG_UNIQUE} ${FLAG_PRESERVE_NULL_ITEMS} -s "${SEP}" "${RESULTS[@]}"
}
